{
  "metadata": {
    "generated_at": "2026-01-17",
    "auditor": "Claude Opus 4.5",
    "total_errors": 19,
    "critical": 4,
    "high": 3,
    "medium": 5,
    "low": 7
  },
  "errors": [
    {
      "id": 1,
      "severity": "CRITICAL",
      "file": "engine/tools/consolidar_cola.py",
      "line": "53-66",
      "type": "RACE_CONDITION",
      "title": "FileLock con potencial deadlock",
      "description": "El metodo acquire() usa loop infinito sin proteccion contra deadlocks. Si dos procesos intentan adquirir el lock simultaneamente en Windows, puede haber bloqueo indefinido. Ademas, no se libera el fd abierto antes de retornar False en timeout.",
      "impact": "Datos pueden quedarse sin sincronizar o corromperse si bot_dreamer y juez ejecutan simultaneamente",
      "fix": "Implementar threading.Lock() o usar portalocker. Asegurar que fd se cierra en todos los paths de retorno.",
      "status": "PENDING"
    },
    {
      "id": 2,
      "severity": "CRITICAL",
      "file": "engine/models/bot_dreamer.py",
      "line": "382-384",
      "type": "SILENT_FAILURE",
      "title": "OraculoNeural usado sin validar metodos",
      "description": "Si OraculoNeural falla al cargar, se setea a None. Pero luego 'if OraculoNeural:' solo verifica que no es None, sin validar que tenga los metodos necesarios. Esto causa AttributeError silencioso.",
      "impact": "El bot corre a media capacidad sin error visible. Las predicciones de IA se ignoran completamente.",
      "fix": "Validar que OraculoNeural tiene metodo predecir() antes de usarlo, o usar hasattr().",
      "status": "PENDING"
    },
    {
      "id": 3,
      "severity": "CRITICAL",
      "file": "engine/models/juez_implacable.py",
      "line": "164-171",
      "type": "SECURITY",
      "title": "ast.literal_eval() inseguro",
      "description": "Se usa ast.literal_eval() para parsear listas de numeros. Si el input contiene codigo malicioso o mal formateado, puede fallar o ejecutar codigo no intendido.",
      "impact": "Riesgo de seguridad. Inyeccion de codigo posible si datos vienen de fuente externa.",
      "fix": "Reemplazar con json.loads() que es mas seguro para parsear estructuras de datos.",
      "status": "PENDING"
    },
    {
      "id": 4,
      "severity": "CRITICAL",
      "file": "engine/models/consolidar_laboratorio.py",
      "line": 41,
      "type": "DATA_CORRUPTION",
      "title": "NaN sanitization fragil",
      "description": "La condicion (v == v) para detectar NaN es fragil. Si hay valores infinitos o tipos complejos, la serializacion JSON falla.",
      "impact": "Dashboard puede corromperse con registros vacios o causar crash.",
      "fix": "Usar pd.isna() de pandas o math.isnan()/math.isinf() explicitamente.",
      "status": "PENDING"
    },
    {
      "id": 5,
      "severity": "HIGH",
      "file": "engine/models/bot_dreamer.py",
      "line": "367-375",
      "type": "LOGIC_ERROR",
      "title": "Loop de consenso puede terminar con menos de 5 muestras",
      "description": "El contador validas se incrementa dentro del if, pero reintentos siempre. Si hay muchos rechazos, se sale del loop antes de conseguir 5 validas (reintentos < 30).",
      "impact": "El consenso puede basarse en <5 muestras, reduciendo confiabilidad estadistica.",
      "fix": "Cambiar a 'while validas < 5 and reintentos < 100:' o aumentar limite de reintentos.",
      "status": "PENDING"
    },
    {
      "id": 6,
      "severity": "HIGH",
      "file": "engine/models/oraculo_neural.py",
      "line": "318-319",
      "type": "INDEX_ERROR",
      "title": "Acceso a indices negativos si X_raw es pequeno",
      "description": "Si len(X_raw) < self.window_size, el loop accede a indices negativos de forma inesperada, produciendo comportamiento impredecible.",
      "impact": "IndexError silencioso o predicciones incorrectas con datasets pequenos.",
      "fix": "Validar 'if len(X_raw) < self.window_size: return []' antes del loop.",
      "status": "PENDING"
    },
    {
      "id": 7,
      "severity": "HIGH",
      "file": "engine/scrapers/scraper_maestro.py",
      "line": 249,
      "type": "TIMEOUT_ERROR",
      "title": "Timeout de 3 segundos muy corto para Polla.cl",
      "description": "El asyncio.sleep(3) despues de goto() es insuficiente en conexiones lentas. El token CSRF nunca se obtiene y el scraper falla.",
      "impact": "Scraper falla frecuentemente en redes lentas o cuando el servidor esta lento.",
      "fix": "Aumentar a 10+ segundos o usar wait_until='networkidle'.",
      "status": "PENDING"
    },
    {
      "id": 8,
      "severity": "MEDIUM",
      "file": "engine/models/bot_dreamer.py",
      "line": "124, 131",
      "type": "EXCEPTION_HANDLING",
      "title": "Excepcion generica sin logging especifico",
      "description": "Se capturan TODAS las excepciones con 'except:' sin especificar tipo. Si hay error diferente al esperado, se intenta fallback que tambien falla.",
      "impact": "Dificil debuggear problemas de parsing de fechas.",
      "fix": "Especificar 'except ValueError:' y loguear el error especifico.",
      "status": "PENDING"
    },
    {
      "id": 9,
      "severity": "MEDIUM",
      "file": "engine/models/loto3_tricore.py",
      "line": 111,
      "type": "VALIDATION_MISSING",
      "title": "Acceso a X.iloc[[-1]] sin validar que X tenga datos",
      "description": "No hay validacion de que X tenga al menos 1 fila antes de acceder al ultimo elemento.",
      "impact": "IndexError en prediccion de LOTO3 si datos estan vacios.",
      "fix": "Validar 'if len(X) == 0: return None' antes del acceso.",
      "status": "PENDING"
    },
    {
      "id": 10,
      "severity": "MEDIUM",
      "file": "varios",
      "line": "-",
      "type": "CONFIG_DUPLICATION",
      "title": "HORARIOS y GAME_CONFIG duplicados en 4+ archivos",
      "description": "Los mismos datos se definen en bot_dreamer.py, config.py, scraper_maestro.py, oraculo_neural.py. Si se actualiza uno y no los demas, hay inconsistencia.",
      "impact": "Bugs sutiles por falta de sincronizacion entre archivos.",
      "fix": "Centralizar TODO en config.py e importar desde ahi.",
      "status": "PENDING"
    },
    {
      "id": 11,
      "severity": "MEDIUM",
      "file": "engine/models/analizador_forense.py",
      "line": "176-192",
      "type": "PERFORMANCE",
      "title": "Loop de 5000 intentos en predict_smart_gaussian",
      "description": "Si los filtros son muy restrictivos, consume 5000 iteraciones innecesariamente. En contexto de bot_dreamer (50 intentos x multiples algoritmos), esto es lento.",
      "impact": "Rendimiento degradado, predicciones pueden tardar mucho.",
      "fix": "Reducir attempts < 5000 a attempts < 100 o 200.",
      "status": "PENDING"
    },
    {
      "id": 12,
      "severity": "MEDIUM",
      "file": "engine/models/entrenador_cognitivo.py",
      "line": 210,
      "type": "DATA_VALIDATION",
      "title": "groupby().unstack() puede fallar con datos vacios",
      "description": "Si no hay datos para cierta hora, la estructura puede ser inconsistente. El .unstack() puede fallar si no hay pivot valido.",
      "impact": "Error ocasional en entrenamiento si hay datos vacios por hora.",
      "fix": "Anadir validacion 'if perf_horaria.empty: continue'.",
      "status": "PENDING"
    },
    {
      "id": 13,
      "severity": "LOW",
      "file": "loto_parser_v3.py, loto_parsers_mix.py",
      "line": "-",
      "type": "CODE_DUPLICATION",
      "title": "Logica de parseo duplicada entre archivos",
      "description": "Ambos archivos tienen manejo similar de errores pero codigo diferente. Dificil mantener.",
      "impact": "Posible divergencia de bugs entre parsers.",
      "fix": "Consolidar en un unico modulo parsers.py.",
      "status": "PENDING"
    },
    {
      "id": 14,
      "severity": "LOW",
      "file": "engine/models/juez_implacable.py",
      "line": "68-127",
      "type": "SCORING_INCONSISTENCY",
      "title": "Escala de afinidad no normalizada por n_balls",
      "description": "En entrenador_cognitivo.py se usa 'aciertos' directamente como peso, sin normalizar por maximo de aciertos del juego.",
      "impact": "Distorsion leve en ranking de algoritmos por juego.",
      "fix": "Normalizar pesos por maximo de aciertos del juego.",
      "status": "PENDING"
    },
    {
      "id": 15,
      "severity": "LOW",
      "file": "engine/scrapers/scraper_maestro.py",
      "line": "39-46, 341",
      "type": "NULL_CHECK_MISSING",
      "title": "Parser puede ser None pero se usa sin validar",
      "description": "Si parsers faltan, se setean a None, pero luego game['parser'] se asume callable.",
      "impact": "Scraper falla sin mensaje claro si parsers faltan.",
      "fix": "Validar 'if game[\"parser\"] is None: skip this game'.",
      "status": "PENDING"
    },
    {
      "id": 16,
      "severity": "LOW",
      "file": "engine/models/entrenador_cognitivo.py",
      "line": 257,
      "type": "SECURITY",
      "title": "ast.literal_eval() en lugar de json.loads()",
      "description": "Se usa ast.literal_eval() para parsear listas cuando json.loads() es mas seguro.",
      "impact": "Riesgo menor de seguridad en contexto local.",
      "fix": "Reemplazar con json.loads().",
      "status": "PENDING"
    },
    {
      "id": 17,
      "severity": "LOW",
      "file": "varios",
      "line": "-",
      "type": "INCONSISTENT_LOGGING",
      "title": "Mezcla de print() y logger sin coherencia",
      "description": "Algunos archivos usan print(), otros logger.xxx(). Inconsistente y dificil capturar output.",
      "impact": "Dificil debuggear, logs incompletos.",
      "fix": "Reemplazar todos los print() con logger.info() o similar.",
      "status": "PENDING"
    },
    {
      "id": 18,
      "severity": "LOW",
      "file": "engine/models/loto3_tricore.py",
      "line": "23-24",
      "type": "PATH_HANDLING",
      "title": "Rutas relativas debiles con os.path.dirname",
      "description": "Si el archivo se ejecuta desde un path diferente, PROJECT_ROOT puede calcularse mal.",
      "impact": "Fallos ocasionales si se ejecuta desde directorio distinto.",
      "fix": "Usar pathlib.Path o os.path.realpath().",
      "status": "PENDING"
    },
    {
      "id": 19,
      "severity": "LOW",
      "file": "engine/tools/consolidar_cola.py",
      "line": 41,
      "type": "CODE_CLARITY",
      "title": "Condicion v == v para detectar NaN es confusa",
      "description": "La condicion (v == v) aprovecha que NaN != NaN, pero es poco clara para otros desarrolladores.",
      "impact": "Mantenibilidad reducida.",
      "fix": "Documentar o usar math.isnan() explicitamente.",
      "status": "PENDING"
    }
  ],
  "summary": {
    "by_severity": {
      "CRITICAL": 4,
      "HIGH": 3,
      "MEDIUM": 5,
      "LOW": 7
    },
    "by_type": {
      "RACE_CONDITION": 1,
      "SILENT_FAILURE": 1,
      "SECURITY": 2,
      "DATA_CORRUPTION": 1,
      "LOGIC_ERROR": 1,
      "INDEX_ERROR": 1,
      "TIMEOUT_ERROR": 1,
      "EXCEPTION_HANDLING": 1,
      "VALIDATION_MISSING": 1,
      "CONFIG_DUPLICATION": 1,
      "PERFORMANCE": 1,
      "DATA_VALIDATION": 1,
      "CODE_DUPLICATION": 1,
      "SCORING_INCONSISTENCY": 1,
      "NULL_CHECK_MISSING": 1,
      "INCONSISTENT_LOGGING": 1,
      "PATH_HANDLING": 1,
      "CODE_CLARITY": 1
    },
    "priority_order": [
      "ID 3: ast.literal_eval() inseguro (SECURITY)",
      "ID 1: FileLock con deadlock potencial",
      "ID 2: OraculoNeural sin validacion",
      "ID 4: NaN sanitization fragil",
      "ID 10: Centralizar GAME_CONFIG",
      "ID 7: Aumentar timeout scraper"
    ]
  }
}
